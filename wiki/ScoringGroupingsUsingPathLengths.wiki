#summary Scoring Groupings Based on Ratios of Average Shortest Paths

= Scoring Groupings Based on Ratios of Average Shortest Paths =

*Step 1*: Given N organisms, assign a unique index from the range (0 to N - 1) to each organism 

*Step 2*: Create a 2D matrix `path[][]` of dimension N by N and initialize all data to _UNCONNECTED_, which can be finite or infinite.  In our implementation _UNCONNECTED_ = 9999. For finite values, this value should be less than half the maximum value that can be stored in its data type.  This is to avoid overflow.

*Step 3*: Set each `path[n][n]` = 0

*Step 4*: For all nodes with index n1 with an adjacent node with index n2: set `path[n1][n2]` = 1

*Step 5*: Finally, run the following algorithm (Floyd-Warshall):

{{{
for(int k = 0; k < numVertices; k++) {
   for(int i = 0; i < numVertices; i++) {
      for(int j = 0; j < numVertices; j++) {
	path[i][j] = Math.min(path[i][j], path[i][k] + path[k][j];
      }
   }
}
}}}

Note that running time is N cubed.  Since no student graph has more than 40 nodes (about 64000 loops) this is not prohibitive. Even with 10000 student trees, the number of loops required is less than one billion, and there are only slightly over two operations per loop. This should be no more than a few seconds work for a modern CPU.

Since this algorithm was designed to score grouping independent of graph structure, directionality is ignored, so `path[i][j] = path[j][i]`

The resulting matrix `path[][]` will contain the shortest path between each combination of pairs of organisms

*Step 6*: Find the _maximum shortest path length_ between two connected organisms. (In the event that no organisms are connected, the maximum shortest path is 0, the distance between a node and itself)

*Step 7*: For any pairs of organisms that are unconnected _(`path[i][j]` = UNCONNECTED)_, set the shortest path length between them _(`path[i][j]`)_ to: _maximum shortest path length_ + 1

The reason for this is so that the algorithm is tolerant of a small number of unconnected nodes

*Step 8*: Find average path length between members of a group as follows: 

For all members of a group (ex. Mammals) take the sum of all `path[i][j]` such that i,j are both mammals and i != j, then divide the result by the number of paths used in the summation.

*Step 9*: Find average path length between members of a group and non-members as follows:  

For all members of a group (ex. Mammals) take the sum of all `path[i][j]` such that i is a mammal and j is a non-mammal, and divide the result by the number of paths used in the summation.

*Final Step*: Compute: 

Average path length between group members and non-members _(result of Step 9)_ _*divided by*_ Average path between group members _(result of Step 8)_

This gives the result of this algorithm

Since the path lengths between group members should be less than the path lengths between group members and non-group members, larger scores are better.<br>
Randomly grouped graphs would score around a 1.0<br>
Lower than 1.0 is worse than random<br>
Greater than 1.0 is better than random<br>

Based on current available student data the grouping scores are classified as follows:

scores <= 1.0 are bad (red)<br>
1.0 < scores < 1.25 are poor to OK (yellow)<br>
scores >= 1.25 are good (green)

While this score is a relatively good indicator of grouping, the score is a bit arbitrary.

Also, an improperly constructed tree can score higher than a properly constructed tree.  For example, a proper tree should not have organisms directly connected to each other.  A properly constructed tree will have a minimum distance of 2 between any pair of organisms.  However, a tree with mammals connected directly to each other would have an average distance between mammals closer to 1, and therefore would score higher.  Indeed trees that score highest on this score are improper trees, but the groupings are very good.